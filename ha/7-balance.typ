#import "../libs/template.typ": *
= Balancing $Ext$ and $Tor$
== Defining $Ext$ and $Tor$ 

#definition[
  Let $cA$ be an abelian category. Let $A, B in cA$ and let $B -> I_cx$ be an injective resolution.
Recall that $Hom(A)(A, -): cA -> Ab$ is left exact by @hom-left-exact.
  If $cA$ has enough injectives, we define the right derived functor $Ext_cA^i (A, -)$ of $Hom(A)(A, -)$ as
  // #footnote[While $Ext_cA^i (A, -)(B)$ (as well as $Ext_cA^i (-, B)(A)$ defined below) is not a common way of writing, it emphasizes the asymmetry of the construction.]
  $ Ext_cA^i (A, B) = Ext_cA^i (A, -)(B) := R^i Hom(A)(A, -)(B) = H^i (Hom(A) (A, I^cx)) $
  In particular, $Ext_cA^0 (A, B) = Hom(A) (A, B)$.
]

Notice that the contravariant functor $Hom(A)(-, B): cA^op -> Ab$ is also left exact by @hom-left-exact-2. Assume that $cA$ has enough projectives, so $A^op$ has enough injectives. Let $P_cx -> A$ be an projective resolution in $cA$, which can be seen as an injective resolution in $cA^op$. We can thus define another right derived functor $Ext_cA^i (-, B)$, given by
$
  Ext_cA^i (-, B)(A) := R^i Hom(A)(-, B) (A) = H^i (Hom(A)(P_cx, A))
$

The above two constructions are in fact isomorphic, i.e., $Ext_cA^i (A, -)(B) iso Ext_cA^i (-, B)(A)$. In other words,
$
  Ext_cA^i (A, B) := R^i Hom(A)(A, -)(B) iso R^i Hom(A)(-, B) (A)
$
This isomorphism is called the *balancing of $Ext$*. Before proving the balancing of $Ext$, we present some properties of $Ext$ that the balancing gives.

#proposition[
  Let $ses(K, L, M)$ be a short exact sequence in $cA$ and let $A, B in cA$. Then we have the induced long exact sequences
  $
    0 -> Hom(A) (A, K) ->  Hom(A) (A, L) ->  Hom(A) (A, M) -> \ Ext_cA^1 (A, K) ->  Ext_cA^1 (A, L) ->  Ext_cA^1 (A, M) -> ...
  $
  and 
  $
    0 -> Hom(A) (K, B) ->  Hom(A) (L, B) ->  Hom(A) (M, B) -> \ Ext_cA^1 (K, B) ->  Ext_cA^1 (L, B) ->  Ext_cA^1 (M, B) -> ...
  $
]
#proof[
  Simply notice that ${Ext_cA^i (A, -)}_(i>=0)$ and ${Ext_cA^i (-, B)}_(i>=0)$ form two cohomological $delta$-functors.
]

#proposition[
  The followings are equivalent:
  + $B$ is injective;
  + $Hom(A)(-, B)$ is exact;
  + $Ext_cA^i (A, B) = 0$ for $i !=0$ and all $A$;
  + $Ext_cA^1 (A, B) = 0$ for all $A$.]

#proof[
  (1) $<=>$ (2) by the definition of injective objects.

  (1) $=>$ (3) by applying the dual of @projective-left-zero to $Ext_cA^i (A, -)$. 

  (3) $=>$ (4) is trivial.

  (4) $=>$ (2). Let $ses(A', A, A'')$ be a short exact sequence in $cA$, which induces the #lest 
  $
    0 -> Hom(A) (A', B) -> Hom(A) (A, B) -> Hom(A) (A'', B) -> Ext^1_cA (A', B) -> ...
  $
  Since $Ext^1_cA (A', B) = 0$ by assumption,  $Hom(A) (-, B)$ is an exact functor.
]
#proposition[
  The followings are equivalent:
  + $A$ is projective;
  + $Hom(A)(A, -)$ is exact;
  + $Ext_cA^i (A, B) = 0$ for $i !=0$ and all $B$;
  + $Ext_cA^1 (A, B) = 0$ for all $B$.
]
#proof[
  Similar as above.
]

#definition[
  Let $R$ be a ring and $B$ be a left $R$-module. Since $(- tpr B) : ModR -> Ab$ is right exact by @tensor-right-exact and $RMod$ has enough projectives, we can define the left derived functor $Tor_i^R (-, B)$:
  $ Tor_i^R (A, B) = Tor_i^R (-, B)(A) := L_i (- tpr B) (A) $
]

Similarly, let $A$ be a right $R$-module, and $(A tpr - ): RMod -> Ab$ is right exact by @tensor-right-exact-2. We can thus define the left derived functor $Tor_i^R (A, -)$: 
$
  Tor_i^R (A, -)(B) := L_i (A tpr -) (B)
$

The two constructions are again isomorphic, i.e., 

$ Tor_i^R (A, B) := L_i (- tpr B) (A) iso L_i (A tpr -) (B) $

This isomorphism is called *the balancing of $Tor$*, which gives the following property.

#proposition[
  Let $ses(K, L, M)$ be a #sest in $ModR$ and let $B in RMod$. Then we have the induced long exact sequence 
  $
    ... -> Tor_1^R (K, B) -> Tor_1^R (L, B) ->  Tor_1^R (M, B) -> K tpr B -> L tpr B -> M tpr B -> 0
  $
  
  If $ses(K, L, M)$ is instead a #sest in $RMod$ and let $A in ModR$, then we have the induced #lest 
  $
    ... -> Tor_1^R (A, K) -> Tor_1^R (A, L) ->  Tor_1^R (A, M) -> A tpr K -> A tpr L -> A tpr M -> 0
  $
  
]

In order to prove the balancing of $Ext$ and $Tor$, we need two new tools: mapping cones and double complexes, introduced in the following sections.

// #TODO #lest induced by $Tor$ and $Ext$

== Mapping Cones
// #remark[
// In topology,  let $f: X-> Y  $ be a continuous map between two topological spaces. 

//   The *topological mapping cylinder* $M_f$ of $f : X-> Y$ is the quotient
//   $ ((X times I) product.co Y) over tilde $
//   where the equivalence relation $tilde$ is generated by $ (x, 1) tilde f(x)$ for all $x in X$. That is, the mapping cylinder is obtained by gluing one end of $X times I$ to $Y$ via the map $f$. It is often denoted as $(X times I) union.sq_f Y$.

//   The *topological mapping cone* $C_f$ of $f : X-> Y$ is the quotient space of the mapping cylinder $(X times I) union.sq_f Y$ with respect to the equivalence relation $(x, 0) tilde (x', 0)$ for all $x, x' in X$. That is, the end of $X times I$ that is not glued to $Y$ is identified as a point.
//   #align(center,image("../imgs/Mapping_cone.svg",width:30%))
// ]


#definition[Let $f : B_cx -> Ccx$ be a chain map.
 Define the *mapping cone* of $f$ as the chain complex $cone(f)_cx$, given by $ cone(f)_n = B_(n-1) plus.circle C_n $ 
 with differential $ d(b, c) = (-d(b), d(c) - f(b)) $ for $b in B_(n-1)$ and $c in C_n$.
We could also write the differential in the form of a matrix:
$
mat(-d_b, 0; -f, d_c) : vec(B_(n-1), C_n) -> vec(B_(n-2), C_(n-1))
$
]

#lemma[
  Let $f: B_cx -> C_cx$ be a chain map. Then there is a long exact sequence in homology
  $ 
 ... -> H_(n+1) (cone(f)) ->^(delta_ast)  H_n (B) ->^diff H_n (C) -> H_n (cone(f)) -> ...
$
  where the connecting morphism 
  $ diff = f_ast $
]
#proof[
There is a #sest of chain complexes:
$ ses(C, cone(f), B[-1], f: i, g: pi) $
where $i: c mapsto (0, c)$ and $pi : (b, c) |-> -b$. Notice that $H_(n+1)(B[-1]) = H_n (B)$, so we get the corresponding #lest in homology as above by @connecting.

  Further, we have $diff = i^(-1) d_(cone(f)) pi^(-1)$ by @connecting.
  Let $b in B_n$ be a cycle. We can lift it to $(-b, 0)$ in $cone(f)$. Apply the differential of $cone(f)$ to get $d_(cone(f)) ( -b, 0) = (d (b), f (b)) = (0, f (b))$. Thus $diff[b] = [f (b)] = f_ast [b]$.
]
#corollary[
  $f: B_cx -> C_cx$ is a quasi-isomorphism if and only if $cone(f)$ is acyclic.
]
   <cone-qi>
#proof[
  "$=>$". If $f$ is a quasi-isomorphism, then $f_ast : H_n (B) -> H_n (C)$ is an isomorphism for all $n$. Then we have an exact
sequence
$ H_n (B) arrow.r^(f_ast) H_n (C) arrow.r^(i_ast) H_n ("cone"(f)) arrow.r^(pi_ast) H_(n - 1) (B) arrow.r^(f_ast) H_(n - 1) (C)  $

By exactness at $H_n (C)$,  we have that
$ Ker (i_ast) = IM(f_ast) = H_n (C)$. So $i_ast = 0$ and $IM(i_ast) = 0$. 
By exactness at $H_(n - 1) (B)$, we have that
$ "Im"(pi_ast) = Ker(f_ast) = 0$, so $pi_ast = 0$ and $ Ker (pi_ast) = H_n ("cone"(f))$. 

By exactness at $H_n ("cone"(f))$, we
have $ 0 = IM(i_ast) = Ker (pi_ast) = H_n ("cone"(f)) $ so
$cone(f)$ is acyclic.

"$arrow.l.double$". If cone $(f)$ is
acyclic, then $H_n ("cone"(f)) = 0$ and we have an exact sequence
$ 0 arrow.r H_n (B) arrow.r^(f_ast) H_n ("cone"(f)) arrow.r 0  $
which indicates that $f_ast$ is an isomorphism.
]


#definition[
  The *mapping cylinder* of a chain map $f: B_cx -> C_cx$ is defined as the chain complex $cyl(f)_n = B_n xor B_(n-1) xor C_n$. The differential can be represented by the matrix 
  $
    mat(d_B, id_B, 0;0, -d_B, 0; 0, -f, d_C)
  $
]

#remark[
  The reader is directed to @weibel[Section 1.5] for some topological remarks on mapping cones and mapping cylinders.
]
// #remark[
// Let $0->B->^f C->^g D-> 0$ be a #sest of complexes. Then $phi: cone(f) -> D$ has $phi(b, c)-> g(c)$.#align(center,image("../imgs/2023-11-10-12-30-40.png",width:50%)) You can prove $cyl(f)-> C$ is a quasi-isomorphism and also $phi$ is quasi-isomorphism. (This is non-examinable.)
// ]
== Double Complexes and Total Complexes
Recall that if $cA$ is an abelian category,  $Ch(cA)$ is also an abelian category. Then to define a "two-dimensional" complex, one may be tempted to consider the category $Ch(Ch(cA))$. However, what we define next is slightly different from that.
#definition[
  A *double complex* (or *bicomplex*) $C = C_(cx cx)$ in an abelian category $cA$ is a family ${C_(p, q)}$ of objects in $cA$ with maps $d^h_(p, q) : C_(p, q) -> C_(p-1, q)$ and $d^v_(p, q) : C_(p, q) -> C_(p, q-1)$ such that $ (d^h)^2 = (d^v)^2 = 0 $ and $ d^v d^h + d^h d^v = 0 $
]

In other words, a double complex is an infinite two-dimensional grid of objects where each row (resp. each column) is a chain complex, and the horizontal and vertical differentials _anticommute_. A diagram for a double complex is shown as below; this is not a commutative (but an anticommutative) diagram.

// https://t.yw.je/#N4Igdg9gJgpgziAXAbVABwnAlgFyxMJZARgBpiBdUkANwEMAbAVxiRAGEB9ACjQFoyAAgCOAamIBKEAF9S6TLnyEUAJnJVajFmy69SI8VNnzseAkQDM66vWatEHHmnH6xkmXJAZTSomRUattoOuvxCwkae3ormqqQBNlr2jnoikSYxyshWCZp2Ok4uaR4ZZllkFoFJBbwCrgLpXgplRGqVifkhTvXuxk0+sdmk7XnBKc7hDSX9mUQALNajyQB0q9PRLSgLuUEra30bvlvDVZ0gq8vrzUdDc6djF1cDWWp3HQ-7UdeDZG9LbI8Dt8sgAGE7vPaXIHPIhgnbVByAr4wlBgygQgGfUo3Kwg+6Qp6zOJ4jGIrEzTYkUgk-5kqEaGBQADm8CIoAAZgAnCAAWyQCxAOAgSAA7KSQFAAHo0aZc3lIMiC4WIAW7NhSmV9OV8xBgpVIKy0iXS2XcnWGoVIABs4o1pvliDU+sQAFZbSatWakG7nQAOd2azzahXUS2690AC3tOqdYcVaocUqjnodAE5Q8qVCmdcQ9WGXdnvRn+ZHoyXnYaE8bk0GvYgxc6bUak2XEP7nQ2qy3C4hiIqw76e+241naw6G3GLD2m3G5tPi72C2PzQviFae3nlcQRT3iMPM7v087iD2VJukCDpBRpEA
#align(center, commutative-diagram(
  node-padding: (50pt, 50pt),
  node((1, 1), [$C_(p-1, q+1)$]),
  node((1, 2), [$C_(p, q+1)$]),
  node((1, 3), [$C_(p+1, q+1)$]),
  node((2, 1), [$C_(p-1, q)$]),
  node((2, 2), [$C_(p, q)$]),
  node((2, 3), [$C_(p+1, q)$]),
  node((3, 1), [$C_(p-1, q-1)$]),
  node((3, 2), [$C_(p, q-1)$]),
  node((3, 3), [$C_(p+1, q-1)$]),
  node((1, 4), [$...$]),
  node((2, 4), [$...$]),
  node((3, 4), [$...$]),
  node((4, 3), [$...$]),
  node((4, 2), [$...$]),
  node((4, 1), [$...$]),
  node((3, 0), [$...$]),
  node((2, 0), [$...$]),
  node((1, 0), [$...$]),
  node((0, 3), [$...$]),
  node((0, 2), [$...$]),
  node((0, 1), [$...$]),
  arr((2, 2), (3, 2), [$d^v$]),
  arr((1, 2), (2, 2), [$d^v$]),
  arr((1, 1), (2, 1), [$d^v$]),
  arr((2, 1), (3, 1), [$d^v$]),
  arr((1, 3), (2, 3), [$d^v$]),
  arr((2, 3), (3, 3), [$d^v$]),
  arr((1, 2), (1, 1), [$d^h$]),
  arr((1, 3), (1, 2), [$d^h$]),
  arr((1, 4), (1, 3), []),
  arr((2, 4), (2, 3), []),
  arr((2, 3), (2, 2), [$d^h$]),
  arr((2, 2), (2, 1), [$d^h$]),
  arr((3, 2), (3, 1), [$d^h$]),
  arr((3, 3), (3, 2), [$d^h$]),
  arr((3, 4), (3, 3), []),
  arr((3, 3), (4, 3), []),
  arr((3, 2), (4, 2), []),
  arr((3, 1), (4, 1), []),
  arr((3, 1), (3, 0), []),
  arr((2, 1), (2, 0), []),
  arr((1, 1), (1, 0), []),
  arr((0, 3), (1, 3), []),
  arr((0, 2), (1, 2), []),
  arr((0, 1), (1, 1), []),
))

// #align(center,image("../imgs/2023-11-12-16-01-47.png",width:50%))
#remark[
  Because the differentials anticommute, $d^v$ cannot be seen as chain maps between rows. 
  We need to replace $d^v_(p, q)$ by $f_(p, q) := (-1)^p d^v_(p, q)$ (so that the signs alternate for adjacent columns) to make the squares commute. For example, the following is a commutative diagram:
// https://t.yw.je/#N4Igdg9gJgpgziAXAbVABwnAlgFyxMJZABgBoBGAXVJADcBDAGwFcYkQBhAfQAoziAlCAC+pdJlz5CKchWp0mrdtx6zBIsSAzY8BIgCY5NBizaJOvQ+tHidUov3kml5lWXJCbWibunI1TopmnKoUnpraknooVoGmypZhGrZRfgDMpMRxLhY8GR7J3nbRyPnZwSoZ1vIwUADm8ESgAGYAThAAtkgALDQ4EEgZCvHmUAB6ABaFbZ1IAKx9A4i9wznjU14zXYiyIP1IZKvB69Pt24Z7S7vOx5Ons4hD+4iHN+zjtPfbK8-XQewAWg+X3miyQFzeozGn02ZyQADYwYgFkd3ndYQ8AOxIiH-KEbTRbBFI7Go8xA6EiSjCIA
#align(center, commutative-diagram(
  node-padding: (50pt, 50pt),
  node((1, 0), [$C_(0,0)$]),
  node((1, 1), [$C_(1,0)$]),
  node((1, 2), [$C_(2,0)$]),
  node((0, 0), [$C_(0,1)$]),
  node((0, 1), [$C_(1,1)$]),
  node((0, 2), [$C_(2,1)$]),
  node((0, 3), [$C_(3,1)$]),
  node((1, 3), [$C_(3,0)$]),
  arr((0, 1), (0, 0), [$d^h$]),
  arr((0, 2), (0, 1), [$d^h$]),
  arr((1, 1), (1, 0), [$d^h$]),
  arr((1, 2), (1, 1), [$d^h$]),
  arr((0, 0), (1, 0), [$d^v$]),
  arr((0, 1), (1, 1), [$-d^v$]),
  arr((0, 2), (1, 2), [$d^v$]),
  arr((0, 3), (0, 2), [$d^h$]),
  arr((1, 3), (1, 2), [$d^h$]),
  arr((0, 3), (1, 3), [$-d^v$]),
))
Therefore, $f_(cx, q) : C_(cx, q) -> C_(cx, q-1)$ is a chain map between two adjacent rows.
This also gives an isomorphism between the category of bicomplexes in $cA$ and $Ch(Ch(cA))$.] <sign-trick>

#definition[
  Let $C_(bullet bullet)$ be a double complex. We say that
$C_(bullet bullet)$ is an *upper half-plane complex* if there is some
$q_0$ such that $C_(p q) eq 0$ for all $q lt q_0$. Similarly,
$C_(bullet bullet)$ is a *right half-plane complex* if there is some $p_0$
such that $C_(p q) eq 0$ for all $p lt p_0$.
]

#definition[
  Given $C = {C_(p, q)}$, we can define the *total complex*
  $ Tot^Pi (C)_n = product_(p + q = n) C_(p, q) $
  as well as the finite version 
  $ Tot^xor (C)_n = plus.circle.big _(p+q=n) C_(p, q) $
  with differential $ d = d^h + d^v $
]
#lemma[
  In a total complex, we have that $d^2 = 0$, so the total complex is indeed a chain complex. 
]
#proof[
  @rotman[Lemma 10.5]. 
  $
    d^2 = (d^h + d^v) (d^h + d^v) = (d^h)^2 + (d^h d^v + d^v d^h) + (d^v)^2 = 0
  $
  (This is why we have defined double complexes in the anticommuting way.)
]
The total complex is illustrated by the colours in the following diagram; each “diagonal
slice” is given a different colour. For example, $Tot(C_(cx cx))_0$ is the product of all the
blue terms. This diagram also helps explain how the differential of the total complex works. For example, take $ c = (..., c_(-1, 1), c_(0, 0), c_(1, -1), ...) in product_(p in ZZ) C_(-p, p) = Tot(C)_0 $
Then 
$ d (c) = ( ...,  
underbrace(d^v (c_(-1, 1)) + d^h (c_(0,0)), in C_(-1, 0)) , 
underbrace(d^v (c_(0, 0)) + d^h (c_(1, -1)), in C_(0, -1)), ... ) in Tot(C)_(-1) $
// #align(center,image("../imgs/2023-11-12-16-04-08.png",width:50%))

// https://t.yw.je/#N4Igdg9gJgpgziAXAbVABwnAlgFyxMJZARgBpiBdUkANwEMAbAVxiRAGEB9ACgFoyABMQCUIAL6l0mXPkIoATOSq1GLNl24AGcqIlTseAkQDMS6vWatEHHmRHjJIDAdlEy85RbXWN-Upt1HZxkjBVIPc1UrGy1-QP0QuWRTCJVLdVs4hwTDJLJjTyiMvkF+eKdpXKJFAsj0nx5tATLsipdQ5NJatO8Y0vs9NsSiABYzHuiAOmnW4KqUMdSvKZnBudcFrsL6kGnJ2cqNzpHt3r2D9qTFE7qz1aDDjrIbibZztcek7W7lt-uco7aJZFazvB6XIjaSi3Fb7D4QlCmTSnWEXYZhZEwv5w8Hokj+FHY8TKGBQADm8CIoAAZgAnCAAWyQYxAOAgSAA7FjrFAAHo0Vp0xlIMis9mIFm-Hn8wX0pmIbRipCmV7SgWDIXylVspAANm5ID56scmqQiiViAArAajbLhVbqDrEAAOG0yjVykWO8WKqWG3kACzt8vNTtFfr5QY99oAnN6zdH5cRFU7LYmkNaLZKQf6oybPRL44gVRHA8HOUX9arc+WXUWudXI7XiKKnc703WLcR5B2G2HjB2q2GRoOi8Q0-n7drxcRdR2UzOOR3iK6LT3J0m412O-IF0hNGIKGIgA
#align(center, commutative-diagram(
  node-padding: (50pt, 50pt),
  node((1, 1), text(blue)[$C_(-1, 1)$]),
  node((1, 2), text(orange)[$C_(0,1)$]),
  node((1, 3), text(navy)[$C_(1,1)$]),
  node((2, 1), text(red)[$C_(-1,0)$]),
  node((2, 2), text(blue)[$C_(0,0)$]),
  node((2, 3), text(orange)[$C_(1,0)$]),
  node((3, 1), text(green)[$C_(-1, -1)$]),
  node((3, 2), text(red)[$C_(0, -1)$]),
  node((3, 3), text(blue)[$C_(1, -1)$]),
  node((1, 4), [$...$]),
  node((2, 4), [$...$]),
  node((3, 4), [$...$]),
  node((4, 3), [$...$]),
  node((4, 2), [$...$]),
  node((4, 1), [$...$]),
  node((3, 0), [$...$]),
  node((2, 0), [$...$]),
  node((1, 0), [$...$]),
  node((0, 3), [$...$]),
  node((0, 2), [$...$]),
  node((0, 1), [$...$]),
  arr((2, 2), (3, 2), [$d^v$]),
  arr((1, 2), (2, 2), [$d^v$]),
  arr((1, 1), (2, 1), [$d^v$]),
  arr((2, 1), (3, 1), [$d^v$]),
  arr((1, 3), (2, 3), [$d^v$]),
  arr((2, 3), (3, 3), [$d^v$]),
  arr((1, 2), (1, 1), [$d^h$]),
  arr((1, 3), (1, 2), [$d^h$]),
  arr((1, 4), (1, 3), []),
  arr((2, 4), (2, 3), []),
  arr((2, 3), (2, 2), [$d^h$]),
  arr((2, 2), (2, 1), [$d^h$]),
  arr((3, 2), (3, 1), [$d^h$]),
  arr((3, 3), (3, 2), [$d^h$]),
  arr((3, 4), (3, 3), []),
  arr((3, 3), (4, 3), []),
  arr((3, 2), (4, 2), []),
  arr((3, 1), (4, 1), []),
  arr((3, 1), (3, 0), []),
  arr((2, 1), (2, 0), []),
  arr((1, 1), (1, 0), []),
  arr((0, 3), (1, 3), []),
  arr((0, 2), (1, 2), []),
  arr((0, 1), (1, 1), []),
))

#endlec(10)

#lemma("Acyclic Assembly Lemma")[
  Let $C = {C_(p, q)}$ be a double complex. If
  + $C$ is an upper half-plane complex with exact columns, or
  + $C$ is a right half-plane complex with exact rows,
  then $Tot^Pi (C)$ is acyclic.
  If 
  3. $C$ is an upper half-plane complex with exact rows, or
  4. $C$ is a right half-lane complex with exact columns,

  then $Tot^xor (C)$ is acyclic.
]
  <aal>
#proof[@weibel[Lemma 2.7.3] explains why proving (1) is sufficient to prove all four conditions, so we work on (1) only.
  Let $C$ be an upper half-plane bicomplex with exact columns, where we assume $C_(p, q) = 0$ when $q < 0$ (by translating $C$ up or down). It is sufficient to show that 
  $ H_0 (Tot^Pi (C)) = 0 $
  since by translating $C$ left and right, this will indicate that $H_n (Tot^Pi (C)) = 0$ for all $n$.
  
  Let $ c = (..., c_(-2, 2), c_(-1, 1), c_(0, 0)) in product C_(-p, p) = Tot^Pi (C)_0 $ be a $0$-cycle, i.e., $d(c) = 0$.
  We will use induction to find elements $b_(-p, p+1) in C_(-p, p+1)$ for $p >= -1$ such that $ d^v (b_(-p, p+1)) + d^h (b_(-p+1, p)) = c_(-p, p) $

  For the base case, let $b_(1,0) = 0$ for $p = -1$. Since the $0$-th column is exact, there exists $b_(0,1) in C_(0,1)$ such that $d^v (b_(0,1)) = c_(0,0)$. 
  // https://t.yw.je/#N4Igdg9gJgpgziAXAbVABwnAlgFyxMJZABgBpiBdUkANwEMAbAVxiRAGEB9ACjIEYAlCAC+pdJlz5CKflVqMWbLr3JDR47HgJE+pPnPrNWiDj13E1YkBk1SiZAEwGFxkMRFyYUAObwioADMAJwgAWyRdEBwIJABmakNFEygAPRoRK2CwpDIomMRIxNdU9PUQLPDEB2poiISXNlSACw9hIA
#align(center, commutative-diagram(
  node-padding: (50pt, 50pt),
  node((0, 0), [$C_(0,1)$]),
  node((1, 0), [$C_(0,0)$]),
  node((1, 1), [$C_(1,0)$]),
  node((2, 0), [$0$]),
  arr((1, 0), (2, 0), [$d^v$]),
  arr((0, 0), (1, 0), [$d^v$]),
  arr((1, 1), (1, 0), [$d^h$]),
))
  By induction, suppose we have found $b_(-p+1, p)$ and want to find $b_(-p, p+1)$.
  // https://t.yw.je/#N4Igdg9gJgpgziAXAbVABwnAlgFyxMJZABgBpiBdUkANwEMAbAVxiRAGEB9ACgFo1SAAjQBqAIwBKEAF9S6TLnyEUZMVVqMWbLnwFops+djwEiY0mur1mrRBx79xpfTLkgMxpUTIAmdda07HX5ncQN1GCgAc3giUAAzACcIAFskcxAcCCQAZitNWxAoAD0aVwTktMQyTOzEDIDCkrLDECTUpB9qLPT8mzYSgAsZCmkgA
#align(center, commutative-diagram(
  node-padding: (50pt, 50pt),
  node((0, 0), [$C_(-p, p+1)$]),
  node((1, 0), [$C_(-p,p)$]),
  node((1, 1), [$C_(-p+1,p)$]),
  node((2, 0), [$C_(-p,p-1)$]),
  arr((1, 0), (2, 0), [$d^v$]),
  arr((0, 0), (1, 0), [$d^v$]),
  arr((1, 1), (1, 0), [$d^h$]),
))

 We compute that 
$ d^v lr((c_(minus p comma p) minus d^h lr((b_(minus p plus 1 comma p))))) & eq d^v lr((c_(minus p, p))) plus d^h d^v lr((b_(minus p plus 1 comma p)))\
 & eq d^v lr((c_(minus p, p))) plus d^h lr((c_(minus p plus 1 comma p minus 1))) minus d^h d^h \(b_(minus p plus 2 comma p minus 1 )) \
 & eq 0 dot.basic $

 where $d^v lr((c_(minus p, p))) plus d^h lr((c_(minus p plus 1 comma p minus 1))) = 0$ because $d(c) = 0$. Thus 
 $ c_(minus p comma p) minus d^h lr((b_(minus p plus 1 comma p))) in Ker(d^v : C_(-p, p) -> C_(-p, p-1)) = IM (d^v : C_(-p, p+1) -> C_(-p, p)) $
 
 since the $(minus p)$-th  column is exact. So there exists
$b_(minus p comma p plus 1)$ such that
$ d^v lr((b_(minus p comma p plus 1))) eq c_(minus p comma p) minus d^h lr((b_(minus p plus 1 comma p))) $
as desired. Now assembling all $b_(-p, p+1)$ gives 

$ b = (..., b_(-1, 2), b_(0, 1), b_(1, 0)) in product C_(-p, p+1) = Tot^Pi (C)_(1) $ such that $d (b) =  c$, which proves that $H_0 (Tot^Pi (C)) = 0$. 
]

#remark[
  This lemma is also a consequence of spectral sequences. 
]


== Balancing $Tor$
#definition[
Suppose $P_cx$ is a chain complex in $ModR$ and $Q_cx$ is a chain complex in $RMod$. We can form a double complex of abelian groups which we call the *tensor product double complex*, denoted as $P_cx tpr Q_cx$, where the $(p, q)$ term is $P_p tpr Q_q$ and $d^h = d_P tp 1$ and $d^v = (-1)^p tp d_Q$. 
// The sign trick is to make this anticommute. 
]

#lemma[
  The differentials of $P_cx tpr Q_cx$ anticommute, so $P_cx tpr Q_cx$ is a double complex. 
]
#proof[
  Notice that $(d_P tp 1) oo (1 tp d_Q) = d_P tp d_Q = (1 tp d_Q) oo (d_P tp 1)$ by @tp-composition, and alternating the signs for adjacent columns makes each square anticommute. 
]
#lemma[
  If $P$ is a projective right $R$-module, then the functor $(P tpr -) : RMod -> Ab$ is exact. If $Q$ is a projective left $R$-module, then $(- tpr Q) : ModR -> Ab$ is exact.  #footnote[This is the same as saying "every projective module is flat", but we have yet to define flat modules.]
]
<projective-flat-1>
#proof[
  @rotman[Proposition 3.46, p. 132]. We (very concisely) work on the first half of the claim. First notice that $(R tpr -)$ is an isomorphism by @r-tpr, so the functor $(R tpr -)$ is exact. Then tensor product preserves direct sums by @tensor-right-exact, so for a family of right $R$-modules $M_i$, $((plus.circle.big M_i) tpr -)$ is exact, if and only if $plus.circle.big (M_i tpr -)$ is exact, if and only if each $(M_i tpr -)$ is exact. Now any free module $F$, being a direct sum of $R$'s, must have that $(F tpr -)$ is exact. Finally, $P$ is projective, hence $P$ is a direct summand of some free module by @projective-summand, which indicates that $(P tpr -)$ is also exact.
]
#theorem([Balancing of $Tor$])[ Let $A in ModR$ and $B in RMod$. For all $n$,
  $ Tor_n^R (A, B) = L_n (A tpr -)(B) iso L_n (- tpr B)(A)  $ 
]
#proof[ @weibel[Theorem 2.7.2].
  // #align(center,image("../imgs/2023-11-23-03-00-04.png",width:80%))
  (We drop the dots for chain complexes in this proof.) 
  Choose a projective resolution $P_cx rgt(epsilon) A$ in $ModR$ and a project resolution $Q_cx rgt(eta) B$ in $RMod$. 
  We can view $A, B$ as chain complexes concentrated in degree $0$. Now consider the double complexes $P tpr Q_cx$, $A tpr Q$ and $P tpr B$, and we have _bicomplex morphisms_  $epsilon tp id_Q: P tpr Q -> A tpr Q$ and $id_Q tp eta: P tpr Q -> P tpr B$, which induce chain maps on the total complexes:
  $ f : Tot^xor (P tpr Q) -> Tot^xor (A tpr Q) = A tpr Q $ and
  $ g : Tot^xor (P tpr Q) -> Tot^xor (P tpr B) = P tpr B $
  We claim that $f$ and $g$
  are quasi-isomorphisms, which would give isomorphisms on homology and thus prove the result, i.e.

  $ H_ast (Tot^xor (P tpr Q)) iso H_ast (A tpr Q) = L_ast (A tpr - ) (B) $ 
  $ H_ast (Tot^xor (P tpr Q)) iso H_ast (P tpr B) = L_ast (- tpr B ) (A) $  

  Now we form a double complex $C$, obtained from $P tpr Q$ by adding $A tpr Q$ in the column $p = -1$ using the augmentation $epsilon: P_0 -> A$,
  
// https://t.yw.je/#N4Igdg9gJgpgziAXAbVABwnAlgFyxMJZARgBpiBdUkANwEMAbAVxiRAAUB9ABgAIc0vAIqdiIAL6l0mXPkIoyAJiq1GLNlz4DhPCVJAZseAkUWll1es1aIOo-oJHc90o3KIBmcyqvrbXRQcdZ0lXWRMUM0pLNRs7YiCRMVCDGWN5ZC9o1WsNTkDtJJdUtwiSUm4fWLytR3ziw3CMs0qY3P97QvqUxvSibnIq9pAAQUTRBrT3FAHWnL9R8cVJ0oyBi3m4sa6Q-V7pzIqhhYCliRUYKABzeCJQADMAJwgAWyQAdmocCCQANjaFlBOOwgsl9E9XkgACxfH6IAabNhAkHaMEPZ5vRAAVlh0IBcWRoOKEMxZhA3yQZERtkJqOJGKQXnJcLJvgJwKJKRJSARFMQVLZbAS2iBQnpkMQMOZSFZ1VsAFphYJReLMTjpYgmYLbEreCquQzEP8NQjtSBdfrwYbPhqpWbFUFLeiJQBOXGIAAc+KFjs4YoNEuIVL5NrNtMEaJA3P5wbh6rNFr9qqQXo1xFNcvNvv9Volxr5bpADCwYAJdDgAAtLiBvbYYGhsAwCJzc5jeXDU8XS0jy1WoDXqSB643m3SA5jY5SEV2y5Xq7Whw2sE2wJyKOIgA
#align(center, commutative-diagram(
  node-padding: (50pt, 50pt),
  node((1, 1), [$P_0 tp Q_1$]),
  node((2, 1), [$P_0 tp Q_0$]),
  node((2, 2), [$P_1 tp Q_0$]),
  node((2, 3), [$P_2 tp Q_0$]),
  node((1, 2), [$P_1 tp Q_1$]),
  node((1, 3), [$P_2 tp Q_1$]),
  node((0, 1), [$P_0 tp Q_2$]),
  node((0, 2), [$P_1 tp Q_2$]),
  node((1, 0), [$A tp Q_1$]),
  node((0, 0), [$A tp Q_2$]),
  node((2, 0), [$A tp Q_0$]),
  node((0, 3), [$P_2 tp Q_2$]),
  arr((0, 2), (0, 1), [$d_P tp 1$]),
  arr((1, 2), (1, 1), [$d_P tp 1$]),
  arr((1, 3), (1, 2), [$d_P tp 1$]),
  arr((2, 2), (2, 1), [$d_P tp 1$]),
  arr((2, 3), (2, 2), [$d_P tp 1$]),
  arr((1, 1), (2, 1), [$1 tp d_Q$]),
  arr((1, 2), (2, 2), [$-1 tp d_Q$]),
  arr((1, 3), (2, 3), [$1 tp d_Q$]),
  arr((0, 1), (1, 1), [$1 tp d_Q$]),
  arr((0, 2), (1, 2), [$-1 tp d_Q$]),
  arr((0, 0), (1, 0), [$1 tp d_Q$]),
  arr((0, 3), (0, 2), [$d_P tp 1$]),
  arr((0, 3), (1, 3), [$1 tp d_Q$]),
  arr((1, 0), (2, 0), [$1 tp d_Q$]),
  arr((0, 1), (0, 0), [$epsilon tp 1$], "dashed"),
  arr((1, 1), (1, 0), [$epsilon tp 1$], "dashed"),
  arr((2, 1), (2, 0), [$epsilon tp 1$], "dashed"),
))
  where $C_(-1, q) = A tp Q_q$ and $C_(p, q) = P_p tp Q_q$ for any $p, q >= 0$.
  Then 
  $
    Tot^xor (C)_n  = Tor^xor (P tpr Q)_n xor  (A tp Q_(n+1)) 
  $
  
  Meanwhile, the mapping cone of $f : Tot^xor (P tpr Q) -> A tpr Q $ is  
  $
    cone(f)_n = Tot^xor (P tpr Q)_(n-1) xor (A tp Q_(n))
  $
  
  Hence we observe that $cone(f) = Tot^xor (C)[1]$.
  To show that $f$ is a quasi-isomorphism, we need to show $cone(f)$ is acyclic by @cone-qi. As any $Q_p$ is projective, $(- tpr Q_p)$ is exact  by @projective-flat-1. Since $P_cx -> A$ is a resolution, every row of $C$ is exact. Since $C$ is upper half-plane, $Tot^xor (C)$ is exact by @aal. So $f$ is a quasi-isomorphism. 
  
  Similarly, we can show that $g$ is a quasi-isomorphism by forming a double complex $C'$ obtained from adding $B tpr P$ in the row $q = -1$ of $P tpr Q$.
  // ($Q$ means $id_Q$ in proper places)
]

== Balancing $Ext$

#definition[
Given a chain complex $P_cx$ and a cochain complex $I^cx$, we can form a double complex $ hom(P, I) = {hom (P_p, I^q)} $

For $f : P_p -> I^q$, $a in P_p$ we have $(d^h f) (a) = f (d a)$ and $(d^v f)(a) = (-1)^(p+q+1) d f(a)$. 

Then we define

  $ Tot^Pi (hom(P, I)) $ as the *$hom$ cochain complex*.
]

#remark[If $C, D$ are chain complexes and we reindex $D$ to be a cochain complex. Then $H^n Tot^Pi hom (C, D)$ is the group of chain homotopy eq classes of morphisms $C -> D[-n]$.]

Check: #TODO

$ hom_Ab (Tot^xor (P tp Q), I) iso hom_R (P , Tot^Pi (hom_Ab (Q, I))) $
$I$ cochain complex of abelian groups and $P, Q$ are chain complexes of right/left $R$-modules.


#endlec(11)

#theorem[ For all $n$,
  $ Ext^n_R (A, B) = R^n hom_R (A, -) (B) iso R^n hom_R (-, B) (A) $
] 
#proof[
  #align(center,image("../imgs/2023-11-23-03-27-44.png",width:80%))
  Take projective resolution $P_cx -> A$ and injective resolution $B -> I^cx$. We can view $A$ and $B$ as complexes concentracted at degree $0$. We can form double cochain complexes $hom(P, I)$, $hom(A, I)$ and $hom(P, B)$. Then we need to show 
  $ hom(A, I) -> Tot^Pi hom(P, I) $ and 
  $ hom(P, B) -> Tot^Pi hom(P, I) $ are quasi-isomorphisms. This is equivalent to the cones of the maps being acyclic. 

  We observe that $cone(hom (A, I) -> Tot^Pi hom (P, I))$ is the total complex of the double complex $hom(P, I)$ with $hom(A, I)[-1]$ added.  For this augumented double complex, we see that $Tot^Pi$ is exact by @aal since $hom(P_p, -)$ is exact and $hom(-, I^q)$ is exact. Then 

  $ R^ast hom(A, -) (B) = H^ast hom (A, I) = H^ast Tot^Pi ( hom(P, I))  \ iso H^ast hom(P, B) = R^ast hom(-, B) (A) $
  #TODO review
]
